# Library
A simple project utilizing objects and object constructors to create and display a list of books. Books are stored as objects in an array which will then be used to display the data to the user.

## What is this project?
This project, as the name states, is a library where the individual books are stored as objects inside of an array called "myLibrary." The goal of this project is to practice and get comfortable with using objects and the object constructors, which are new ways to organize code in JavaScript. Due to the forgiving nature of Javascript that makes it easy to make small projects, it can also become your worse enemy when it comes to writing loonger and more complex code. This is why objects and object constructors are important as it helps organize JavaScript code better and make it easier to maintain. Along with learning about objects, this project also presents a great opportunity to go back to forms and tables so we can create and view the books in our library. Styling will be done for the display and regular Javascript will also be used to parse the form and put the data into the webpage through DOM manipulation.

## The use of prototypes
This project also has one unique feature, and that is the use of prototype-based programming which JavaScript notably supports. Prototypes are a unique style of object-oriented programming, and in Javascript they are basically a hidden property that every object has. It is also good to mention that prototypes are objects too, and an object can only have one prototype only. When an object inherits from a prototype, they essentially gain access to all the properties and methods available in the prototype and that could be really powerful in many ways. For example, you could make an object `rogue` that inherits from the object prototype `nissan` which finally inherits from the object prototype `car`. The `car` prototype contains properties and methods available to all cars, like `driving`, `acceleration`, and `speed` for example. `Nissan` as the brand would contain properties and methods like `fuel economy`, `safety rating`, and `type` (SUVs, sedans, or truck). Finally, `rogue`, the model of the car would contain properties and methods unique to it like `cvt`, zero gravity `seat type`, and `flaws`. Why is this a great way of organizing our code? Because we have a general `car` prototype that shares its properties and methods with every single car and also a `nissan` prototype that then shares its own properties and methods with every `nissan` car. Finally, our final object `rogue` has the properties that only applies to itself such as how it uses CVT transmission which most other cars don't.

This makes it easier to organize our code as our general properties and methods are shared among different cars, saving us the time and performance to repeat and create the sames properties and methods when it's unnecessary. It also makes our code look better and easier to understand, which is why this is the first thing I've learnt about organizing JavaScript code so far. Prototypes are not only intuitive, but they also have unique features such as prototypal chains and inheritance which is what we saw in use here. They also contain unique methods for setting and getting prototypes, and personally I think that prototypes are a great way to organize your code. While this section is mainly to practice my understanding of prototype, if you found it interesting you can learn more from the source itself, [The Odin Project](https://www.theodinproject.com/lessons/node-path-javascript-library).

## Closing statements
I'll make this README.md short as sometimes simple is best, and this library project is a simple yet effective for understanding object constructors and prototypes. It doesn't do anything more than it needs to, so I can focus on learning the important stuff while not worrying about being led astray or not being able to complete it at all. They say that practice makes perfect, and in order to perfect my learning of object-oriented programming in JavaScript, this project is the first of many towards perfection. Thank you for reading and I'll see you in the next one ☝️.

## Lessons learned
Coming from factory functions, classes were intuitive and easy to grasp since they have most things in common. However, one big benefit of using classes in JavaScript I have come across when doing this project is how much more intuitive and easy it is to understand. With classes, prototypes are written inside of the class block making it easier to read and understand the connection between the function and the class itself. For example, the changeReadStatus prototype is directly inside of the Book class letting people know instantly the connection rather than having to read a separate block of code. Classes constructors are also a great way to construct new instances, and with that making subclasses becomes easier as well. In other words, while classes are mostly syntactic sugar to make code look better, it also has their own unique properties and make it easier to understand and maintain your code in the future. 

Another big lesson that I've learned from doing the library project is the importance of modularization and the single responsibility principle when writing my code. As I added more and more functionality and code into my library project, it naturally became more and more convulted. By the time I completed it, my code was starting to become a jumble of code like a spaghetti and looking over it became harder to understand. With modularization, it relieved some of the problems with my code but it still is a jumbled mess as I still haven't learn about ES6 modules yet. The other problem was how closely coupled my code became, and when one part of my code was broken or changed it also changed another part of my code. This breaks the single responsibility principle of coding alongside the problem of having closely coupled code. Having learned just how much of a problem it is in this project, I will take extra care from now on to follow these SOLID coding principles so that my code can be better and more understandable in the future.
